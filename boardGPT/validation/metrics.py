"""
Copyright (C) 2025 boardGPT Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import random
import numpy as np
from typing import List, Tuple, Dict, Optional
import sys
import torch
from rich.progress import Progress, TextColumn, BarColumn, TimeElapsedColumn, TimeRemainingColumn
from tqdm import tqdm
from transformers import PreTrainedTokenizerFast

from boardGPT import othello
from boardGPT.datasets.utils import load_othello_data_files
from boardGPT.games.othello import OthelloGame, create_id_to_move_mapping, create_move_mapping


def is_valid(move: str, previous_moves: List[str]) -> bool:
    """
    Check if a move is valid given a sequence of previous moves.
    
    Args:
        move (str): The move to check.
        previous_moves (List[str]): The sequence of previous moves.
        
    Returns:
        bool: True if the move is valid, False otherwise
    """
    # Convert the move_id to move notation
    if move == "BOS":  # BOS token is not a valid move
        return False
    # end if
    
    # Create a new Othello game
    game = OthelloGame()
    
    # Apply all previous moves to the game
    for move in previous_moves:
        # Convert move notation to coordinates
        row, col = game.notation_to_coords(move)
        
        # Make the move
        success = game.make_move(row, col)
        if not success:
            # If a previous move is invalid, the game state is invalid
            return False  # end if
        # end if
    # end for
    
    # Check if the new move is valid
    row, col = game.notation_to_coords(move)
    return game.is_valid_move(row, col)  # end def is_valid
# end def is_valid

def is_valid_game_sequence(game: List[str]) -> bool:
    """
    Check if a game sequence is valid.
    
    Args:
        game (List[str]): List of move notations representing a game sequence
        
    Returns:
        bool: True if the game sequence is valid, False otherwise
        
    Raises:
        ValueError: If any move before the last one is invalid
    """
    # Create a new Othello game
    othello_game = OthelloGame()
    
    # Apply all moves except the last one to the game
    for i, move in enumerate(game[:-1]):
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()
        # end if
        # Convert move notation to coordinates
        row, col = othello_game.notation_to_coords(move)
        
        # Check if the move is valid
        if not othello_game.is_valid_move(row, col):
            print(f"game sequence: {game}")
            print(f"move: {move}")
            raise ValueError(f"Move {i+1} '{move}' is invalid, but it's not the last move")  # end if
        # end if

        # Make the move
        success = othello_game.make_move(row, col)
        if not success:
            raise ValueError(f"Failed to make move {i+1} '{move}', but it's not the last move")  # end if
        # end if
    # end for
    
    # Check the last move separately
    if game:
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()  # end if
        # end if
            
        last_move = game[-1]
        row, col = othello_game.notation_to_coords(last_move)
        
        # Check if the last move is valid
        if not othello_game.is_valid_move(row, col):
            return False  # end if
        # end if
            
        # Make the last move
        success = othello_game.make_move(row, col)
        if not success:
            return False
        # end if
    # end if
    
    return True  # end def is_valid_game_sequence
# end def is_valid


def evaluate_IMR(
        model,
        iter,
        tokenizer: PreTrainedTokenizerFast,
        num_samples: Optional[int] = 1000,
        device: str = "cpu"
) -> float:
    """
    Compute the average rate of invalid moves generated by a model,
    with a live progress bar displaying ETA and current IMR.

    Args:
        model: The model to evaluate
        iter: The data iterator
        tokenizer: The tokenizer to use
        num_samples (int): Number of samples to evaluate
        device (str): Device to use

    Returns:
        float: Average rate of invalid moves
    """
    total_invalid = 0
    total_moves = 0

    with tqdm(total=num_samples, ncols=0) as pbar:
        for seq_i in range(num_samples):
            # Get batch
            X, Y = next(iter)
            X = X.to(device)

            # Forward pass
            with torch.no_grad():
                _, logits, _, _ = model(X)  # logits: (B, 1, vocab_size)

            # For each sequence in batch
            for bi in range(logits.size(0)):
                Xs = X[bi]
                preds = logits[bi]
                pred_token = torch.argmax(preds).item()
                pred_ids = Xs.tolist() + [pred_token]

                # Decode predicted sequence
                pred_moves = tokenizer.decode(pred_ids, skip_special_tokens=True)

                # Validate with Othello rules
                try:
                    othello(pred_moves)
                except ValueError:
                    total_invalid += 1
                total_moves += 1
            # end for

            # Update progress bar
            current_imr = total_invalid / total_moves if total_moves > 0 else 0.0
            pbar.set_description(f"IMR: {current_imr:.4f}")
            pbar.update(1)
        # end for
    # end with

    return total_invalid / total_moves if total_moves > 0 else 0.0
# end evaluate_IMR


def invalid_move_rate(
        model,
        iter,
        tokenizer: PreTrainedTokenizerFast,
        num_samples: Optional[int] = 1000,
        device: str = "cpu"
) -> float:
    """
    Compute the average rate of invalid moves generated by a model.
    
    Args:
        model: The model to evaluate
        iter: The number of iterations to evaluate
        tokenizer: The tokenizer to use
        num_samples (int): Number of samples to evaluate
        device (torch.device): Device to use
        
    Returns:
        float: Average rate of invalid moves
    """
    total_invalid = 0
    total_moves = 0

    # Process each sequence without a progress bar
    for seq_i in range(num_samples):
        # Get batch
        X, Y = next(iter)
        X = X.to(device)

        # X: (B, 60)
        # Y: (B, 60)

        # Generate the next move using the model
        with torch.no_grad():
            _, logits, _, _ = model(X)
        # end with

        # logits: (B, 1, 61)

        # For each sequence
        for bi in range(logits.size(0)):
            # The sequence
            Xs = X[bi]
            preds = logits[bi]
            pred_token = torch.argmax(preds).item()
            pred_ids = Xs.tolist() + [pred_token]

            # Decode
            pred_moves = tokenizer.decode(pred_ids, skip_special_tokens=True)

            # Check game validity
            try:
                othello(pred_moves)
            except ValueError as e:
                total_invalid += 1
                pass
            # end try
            total_moves += 1
        # end for
    # end for
    
    # Compute the invalid move rate
    if total_moves == 0:
        return 0.0  # end if
    # end if
    
    return total_invalid / total_moves
# end invalid_move_rate
