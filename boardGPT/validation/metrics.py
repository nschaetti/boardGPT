"""
Copyright (C) 2025 boardGPT Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import random
import numpy as np
from typing import List, Tuple, Dict, Optional
import sys
import torch
from rich.progress import Progress, TextColumn, BarColumn, TimeElapsedColumn, TimeRemainingColumn

from boardGPT import othello
from boardGPT.datasets.utils import load_othello_data_files
from boardGPT.games.othello import OthelloGame, create_id_to_move_mapping, create_move_mapping


def is_valid(move: str, previous_moves: List[str]) -> bool:
    """
    Check if a move is valid given a sequence of previous moves.
    
    Args:
        move (str): The move to check.
        previous_moves (List[str]): The sequence of previous moves.
        
    Returns:
        bool: True if the move is valid, False otherwise
    """
    # Convert the move_id to move notation
    if move == "BOS":  # BOS token is not a valid move
        return False
    # end if
    
    # Create a new Othello game
    game = OthelloGame()
    
    # Apply all previous moves to the game
    for move in previous_moves:
        # Convert move notation to coordinates
        row, col = game.notation_to_coords(move)
        
        # Make the move
        success = game.make_move(row, col)
        if not success:
            # If a previous move is invalid, the game state is invalid
            return False  # end if
        # end if
    # end for
    
    # Check if the new move is valid
    row, col = game.notation_to_coords(move)
    return game.is_valid_move(row, col)  # end def is_valid
# end def is_valid

def is_valid_game_sequence(game: List[str]) -> bool:
    """
    Check if a game sequence is valid.
    
    Args:
        game (List[str]): List of move notations representing a game sequence
        
    Returns:
        bool: True if the game sequence is valid, False otherwise
        
    Raises:
        ValueError: If any move before the last one is invalid
    """
    # Create a new Othello game
    othello_game = OthelloGame()
    
    # Apply all moves except the last one to the game
    for i, move in enumerate(game[:-1]):
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()
        # end if
        # Convert move notation to coordinates
        row, col = othello_game.notation_to_coords(move)
        
        # Check if the move is valid
        if not othello_game.is_valid_move(row, col):
            print(f"game sequence: {game}")
            print(f"move: {move}")
            raise ValueError(f"Move {i+1} '{move}' is invalid, but it's not the last move")  # end if
        # end if

        # Make the move
        success = othello_game.make_move(row, col)
        if not success:
            raise ValueError(f"Failed to make move {i+1} '{move}', but it's not the last move")  # end if
        # end if
    # end for
    
    # Check the last move separately
    if game:
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()  # end if
        # end if
            
        last_move = game[-1]
        row, col = othello_game.notation_to_coords(last_move)
        
        # Check if the last move is valid
        if not othello_game.is_valid_move(row, col):
            return False  # end if
        # end if
            
        # Make the last move
        success = othello_game.make_move(row, col)
        if not success:
            return False  # end if
        # end if
    # end if
    
    return True  # end def is_valid_game_sequence
# end def is_valid


def invalid_move_rate(
        model,
        iter,
        dataset,
        num_samples: Optional[int] = 1000,
        device: str = "cpu"
) -> float:
    """
    Compute the average rate of invalid moves generated by a model.
    
    Args:
        model: The model to evaluate
        iter: The number of iterations to evaluate
        dataset: The dataset to use
        num_samples (int): Number of samples to evaluate
        temperature (float): Temperature for sampling
        top_k (int): Top-k sampling parameter
        device (torch.device): Device to use
        log (bool): If True, log the validation metrics
        show_progress (bool): If True, display a progress bar showing the number of samples computed
        
    Returns:
        float: Average rate of invalid moves
    """
    total_invalid = 0
    total_moves = 0

    # Process each sequence without a progress bar
    for seq_i in range(num_samples):
        # Get batch
        X, Y = next(iter)
        X = X.to(device)

        # X: (B, 60)
        # Y: (B, 60)

        # Generate the next move using the model
        with torch.no_grad():
            logits = model(X)[0]
        # end with

        # logits: (B, 1, 61)

        # For each sequence
        for bi in range(logits.size(0)):
            # The sequence
            Xs = X[bi]
            preds = logits[bi]
            pred_token = torch.argmax(preds).item()
            pred_moves = dataset.to_moves(Xs.tolist() + [pred_token])

            # Check game validity
            try:
                othello(pred_moves)
            except ValueError as e:
                total_invalid += 1
                pass
            # end try
            total_moves += 1
        # end for
    # end for
    
    # Compute the invalid move rate
    if total_moves == 0:
        return 0.0  # end if
    # end if
    
    return total_invalid / total_moves
# end invalid_move_rate
