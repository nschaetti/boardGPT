import os
import random
import numpy as np
from typing import List, Tuple, Dict, Optional
import sys

# Add the project root to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from boardGPT.datasets.utils import load_othello_dataset
from simulators.othello import OthelloGame, create_id_to_move_mapping, create_move_mapping


def is_valid(move_id: int, previous_moves: List[int]) -> bool:
    """
    Check if a move is valid given a sequence of previous moves.
    
    Args:
        move_id (int): The ID of the move to check
        previous_moves (List[int]): List of previous move IDs (including BOS token)
        
    Returns:
        bool: True if the move is valid, False otherwise
    """
    # Get the mapping from ID to move notation
    id_to_move = create_id_to_move_mapping()
    
    # Skip BOS token (ID 0) if present in previous_moves
    game_moves = [id_to_move[move] for move in previous_moves if move != 0]
    
    # Convert the move_id to move notation
    if move_id == 0:  # BOS token is not a valid move
        return False
    move_notation = id_to_move[move_id]
    
    # Create a new Othello game
    game = OthelloGame()
    
    # Apply all previous moves to the game
    for move in game_moves:
        # Convert move notation to coordinates
        row, col = game.notation_to_coords(move)
        
        # Make the move
        success = game.make_move(row, col)
        if not success:
            # If a previous move is invalid, the game state is invalid
            return False
    
    # Check if the new move is valid
    row, col = game.notation_to_coords(move_notation)
    return game.is_valid_move(row, col)


def invalid_move_rate(
        model,
        data_dir: str,
        split: str = "val",
        data_filename: str = "val.pkl",
        num_samples: int = 1000,
        max_new_tokens: int = 1,
        temperature: float = 1.0,
        top_k: int = None
) -> float:
    """
    Compute the average rate of invalid moves generated by a model.
    
    Args:
        model: The model to evaluate
        data_dir (str): Directory containing the dataset
        split (str): Dataset split to use ("train" or "val")
        data_filename (str): Filename for the dataset
        num_samples (int): Number of samples to evaluate
        max_new_tokens (int): Number of new tokens to generate
        temperature (float): Temperature for sampling
        top_k (int): Top-k sampling parameter
        
    Returns:
        float: Average rate of invalid moves
    """
    # Load the dataset
    sequences = load_othello_dataset(data_dir, split, data_filename)
    
    # Ensure we don't try to sample more sequences than available
    num_samples = min(num_samples, len(sequences))
    
    # Randomly sample sequences
    sampled_sequences = random.sample(sequences, num_samples)
    
    # Get the mapping from ID to move notation
    id_to_move = create_id_to_move_mapping()
    # Get the mapping from move notation to ID
    move_to_id = create_move_mapping()
    
    total_invalid = 0
    total_moves = 0
    
    # Process each sequence
    for sequence in sampled_sequences:
        # Convert sequence to list if it's not already
        if not isinstance(sequence, list):
            sequence = sequence.tolist()
        # end if
        
        # Choose a random length for the opening moves (max 59 to have at least one move to predict)
        max_length = min(59, len(sequence) - 1)
        if max_length <= 0:
            continue  # Skip sequences that are too short
        # end if

        # Length of the opening sequence
        opening_length = random.randint(1, max_length)
        
        # Get opening moves
        opening_moves = sequence[:opening_length]
        
        # Convert opening moves from IDs to move notation
        opening_moves_notation = [id_to_move[move] for move in opening_moves if move != 0]
        
        # Generate the next move using the model
        generated_moves = model.generate_moves(
            sequence=opening_moves_notation,
            max_new_tokens=max_new_tokens,
            temperature=temperature,
            top_k=top_k
        )
        
        # Get the first generated move
        if generated_moves and len(generated_moves) > 0:
            generated_move_notation = generated_moves[0]
            
            # Convert the generated move from notation to ID
            if generated_move_notation in move_to_id:
                generated_move_id = move_to_id[generated_move_notation]
                
                # Check if the generated move is valid
                if not is_valid(generated_move_id, opening_moves):
                    total_invalid += 1
                # end if
                
                total_moves += 1
            # end if
        # end if
    # end for
    
    # Compute the invalid move rate
    if total_moves == 0:
        return 0.0
    # end if
    
    return total_invalid / total_moves
# end invalid_move_rate
