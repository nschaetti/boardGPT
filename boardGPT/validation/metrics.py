"""
Copyright (C) 2025 boardGPT Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import random
import numpy as np
from typing import List, Tuple, Dict, Optional
import sys
import torch
from rich.progress import Progress, TextColumn, BarColumn, TimeElapsedColumn, TimeRemainingColumn

from boardGPT.datasets.utils import load_othello_dataset
from boardGPT.games.othello import OthelloGame, create_id_to_move_mapping, create_move_mapping


def is_valid(move: str, previous_moves: List[str]) -> bool:
    """
    Check if a move is valid given a sequence of previous moves.
    
    Args:
        move (str): The move to check.
        previous_moves (List[str]): The sequence of previous moves.
        
    Returns:
        bool: True if the move is valid, False otherwise
    """
    # Convert the move_id to move notation
    if move == "BOS":  # BOS token is not a valid move
        return False
    # end if
    
    # Create a new Othello game
    game = OthelloGame()
    
    # Apply all previous moves to the game
    for move in previous_moves:
        # Convert move notation to coordinates
        row, col = game.notation_to_coords(move)
        
        # Make the move
        success = game.make_move(row, col)
        if not success:
            # If a previous move is invalid, the game state is invalid
            return False  # end if
        # end if
    # end for
    
    # Check if the new move is valid
    row, col = game.notation_to_coords(move)
    return game.is_valid_move(row, col)  # end def is_valid
# end def is_valid

def is_valid_game_sequence(game: List[str]) -> bool:
    """
    Check if a game sequence is valid.
    
    Args:
        game (List[str]): List of move notations representing a game sequence
        
    Returns:
        bool: True if the game sequence is valid, False otherwise
        
    Raises:
        ValueError: If any move before the last one is invalid
    """
    # Create a new Othello game
    othello_game = OthelloGame()
    
    # Apply all moves except the last one to the game
    for i, move in enumerate(game[:-1]):
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()
        # end if
        # Convert move notation to coordinates
        row, col = othello_game.notation_to_coords(move)
        
        # Check if the move is valid
        if not othello_game.is_valid_move(row, col):
            print(f"game sequence: {game}")
            print(f"move: {move}")
            raise ValueError(f"Move {i+1} '{move}' is invalid, but it's not the last move")  # end if
        # end if

        # Make the move
        success = othello_game.make_move(row, col)
        if not success:
            raise ValueError(f"Failed to make move {i+1} '{move}', but it's not the last move")  # end if
        # end if
    # end for
    
    # Check the last move separately
    if game:
        # Check if the current player has any valid moves
        valid_moves = othello_game.get_valid_moves()
        if not valid_moves:
            # If no valid moves, the player must pass
            othello_game.switch_player()  # end if
        # end if
            
        last_move = game[-1]
        row, col = othello_game.notation_to_coords(last_move)
        
        # Check if the last move is valid
        if not othello_game.is_valid_move(row, col):
            return False  # end if
        # end if
            
        # Make the last move
        success = othello_game.make_move(row, col)
        if not success:
            return False  # end if
        # end if
    # end if
    
    return True  # end def is_valid_game_sequence
# end def is_valid


_IMR_sequences = None


def invalid_move_rate(
        model,
        data_dir: str,
        split: str = "val",
        data_filename: str = "val.pkl",
        num_samples: Optional[int] = 1000,
        temperature: float = 1.0,
        top_k: int = None,
        device: str = "cpu",
        log: bool = False,
        show_progress: bool = False,  # end def invalid_move_rate
) -> float:
    """
    Compute the average rate of invalid moves generated by a model.
    
    Args:
        model: The model to evaluate
        data_dir (str): Directory containing the dataset
        split (str): Dataset split to use ("train" or "val")
        data_filename (str): Filename for the dataset
        num_samples (int): Number of samples to evaluate
        temperature (float): Temperature for sampling
        top_k (int): Top-k sampling parameter
        device (torch.device): Device to use
        log (bool): If True, log the validation metrics
        show_progress (bool): If True, display a progress bar showing the number of samples computed
        
    Returns:
        float: Average rate of invalid moves
    """
    global _IMR_sequences

    # Load the dataset
    if _IMR_sequences is None:
        sequences: List[List[int]] = load_othello_dataset(
            data_dir=data_dir,
            split=split,
            data_filename=data_filename,
            flatten=False,
            log=log
        )
        _IMR_sequences = sequences  # end if
    else:
        sequences: List[List[int]] = _IMR_sequences  # end else
    # end if
    
    # Randomly sample sequences
    if num_samples is not None:
        # Ensure we don't try to sample more sequences than available
        num_samples = min(num_samples, len(sequences))
        sampled_sequences = random.sample(sequences, num_samples)  # end if
    else:
        sampled_sequences = sequences  # end else
    # end if
    
    # Get the mapping from ID to move notation
    id_to_move = create_id_to_move_mapping()
    
    total_invalid = 0
    total_moves = 0

    # Process each sequence without progress bar
    for seq_i, sequence in enumerate(sampled_sequences):
        if log:
            print(f"seq_i: {seq_i}")  # end if
        # end if

        # Convert sequence to list if it's not already
        if not isinstance(sequence, list):
            sequence = sequence.tolist()  # end if
        # end if

        # Choose a random length for the opening moves (max 59 to have at least one move to predict)
        max_length: int = min(59, len(sequence) - 1)
        if max_length <= 0:
            continue  # Skip sequences that are too short  # end if
        # end if

        # Length of the opening sequence
        opening_length: int = random.randint(1, max_length)

        # Get opening moves
        opening_moves: List[int] = sequence[:opening_length]

        # Convert opening moves from IDs to move notation
        opening_moves_notation = [id_to_move[move] for move in opening_moves if move != 0]

        # Generate the next move using the model
        generated_moves: List[str] = model.generate_moves(
            sequence=opening_moves_notation,
            max_new_tokens=1,
            temperature=temperature,
            top_k=top_k,
            device=torch.device(device)
        )

        # Get the first generated move
        if generated_moves and len(generated_moves) > 0:
            # Check if the generated move is valid using the original is_valid function
            if not is_valid_game_sequence(generated_moves):
                total_invalid += 1  # end if
            # end if

            # Alternatively, we could use the new is_valid_game_sequence function:
            # game_sequence = opening_moves_notation + [generated_move_notation]
            # try:
            #     if not is_valid_game_sequence(game_sequence):
            #         total_invalid += 1
            # except ValueError as e:
            #     # If an error is raised for a move before the last one, log it but don't count it
            #     # as an invalid move since the issue is with the dataset, not the model's prediction
            #     print(f"Warning: {e}")
            # # end try

            total_moves += 1  # end if
        # end if
    # end for
    
    # Compute the invalid move rate
    if total_moves == 0:
        return 0.0  # end if
    # end if
    
    return total_invalid / total_moves
# end invalid_move_rate
