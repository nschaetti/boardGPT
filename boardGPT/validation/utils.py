import os
import random
import numpy as np
from typing import List, Tuple, Dict, Optional, Any
import sys

from boardGPT.datasets.utils import load_othello_dataset
from boardGPT.simulators.othello import OthelloGame, create_id_to_move_mapping, create_move_mapping
from boardGPT.validation.metrics import is_valid_game_sequence


def get_errors(
        model,
        data_dir: str,
        split: str = "val",
        data_filename: str = "val.pkl",
        num_samples: int = 1000,
        temperature: float = 1.0,
        top_k: int = None
) -> List[Dict[str, Any]]:
    """
    Return games where the last move (made by the model) is invalid.
    
    Args:
        model: The model to evaluate
        data_dir (str): Directory containing the dataset
        split (str): Dataset split to use ("train" or "val")
        data_filename (str): Filename for the dataset
        num_samples (int): Number of samples to evaluate
        temperature (float): Temperature for sampling
        top_k (int): Top-k sampling parameter
        
    Returns:
        List[Dict[str, Any]]: List of dictionaries containing games with invalid last moves.
                             Each dictionary contains:
                             - 'opening_moves': List of opening moves in notation format
                             - 'generated_move': The invalid move generated by the model
                             - 'valid_moves': List of valid moves that could have been made
    """
    # Load the dataset
    sequences: List[List[int]] = load_othello_dataset(
        data_dir=data_dir,
        split=split,
        data_filename=data_filename,
        flatten=False
    )
    
    # Ensure we don't try to sample more sequences than available
    num_samples = min(num_samples, len(sequences))
    
    # Randomly sample sequences
    sampled_sequences = random.sample(sequences, num_samples)
    
    # Get the mapping from ID to move notation
    id_to_move = create_id_to_move_mapping()

    # Get the mapping from move notation to ID
    move_to_id = create_move_mapping()
    
    # List to store games with invalid moves
    invalid_games = []
    
    # Process each sequence
    for sequence in sampled_sequences:
        # Convert sequence to list if it's not already
        if not isinstance(sequence, list):
            sequence = sequence.tolist()
        # end if
        
        # Choose a random length for the opening moves (max 59 to have at least one move to predict)
        max_length: int = min(59, len(sequence) - 1)
        if max_length <= 0:
            continue  # Skip sequences that are too short
        # end if

        # Length of the opening sequence
        opening_length: int = random.randint(1, max_length)
        
        # Get opening moves
        opening_moves: List[int] = sequence[:opening_length]
        
        # Convert opening moves from IDs to move notation
        opening_moves_notation = [id_to_move[move] for move in opening_moves if move != 0]

        # Generate the next move using the model
        generated_moves: List[str] = model.generate_moves(
            sequence=opening_moves_notation,
            max_new_tokens=1,
            temperature=temperature,
            top_k=top_k
        )

        # Get the first generated move
        if generated_moves and len(generated_moves) > 0:
            generated_move = generated_moves[0]
            
            # Create a game sequence with the opening moves and the generated move
            game_sequence = opening_moves_notation + [generated_move]
            
            # Check if the game sequence is valid
            if not is_valid_game_sequence(game_sequence):
                # Create a new Othello game to get valid moves
                othello_game = OthelloGame()
                
                # Apply all opening moves to the game
                for move in opening_moves_notation:
                    row, col = othello_game.notation_to_coords(move)
                    success = othello_game.make_move(row, col)
                    if not success:
                        # If a previous move is invalid, skip this game
                        break
                # end for
                
                # Get valid moves for the current game state
                valid_moves = []
                for row, col in othello_game.get_valid_moves():
                    valid_move = othello_game.coords_to_notation(row, col)
                    valid_moves.append(valid_move)
                # end for
                
                # Add the game to the list of invalid games
                invalid_games.append({
                    'opening_moves': opening_moves_notation,
                    'generated_move': generated_move,
                    'valid_moves': valid_moves
                })
            # end if
        # end if
    # end for
    
    return invalid_games
# end get_errors